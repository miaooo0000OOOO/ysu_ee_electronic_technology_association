# 运算符 流程控制语句

## 运算符

运算符可以分为算数运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符

参与运算的值，我们称其为操作数

在描述运算符时，我们会称其为n元运算符，n指的是操作数的个数，例如：

减法运算符是二元运算符，表达式可以写作`a-b`，可见有两个操作数参与运算

负号运算符是一元运算符，表达式可以写作`-a`，可见有一个操作数参与运算

虽然都使用负号，但是一个是一元运算符，一个是二元运算符，因为操作数个数不同

### 运算符的优先级和结合性

我们小学就学过，先乘除后加减，在编程中，我们说乘法和除法的优先级比加法和减法高

在优先级相同的情况下，我们从左到右计算，我们称该运算左结合

### 算数运算符

| 运算符 | 描述                                                           |
| ------ | -------------------------------------------------------------- |
| +      | 加法                                                           |
| -      | 当只有一个值参与运算时，取这个值的相反数；有两个值时，计算减法 |
| *      | 乘法                                                           |
| /      | 除法                                                           |
| %      | 模运算，即两数相除的余数 (操作数必须是整型)                    |
| ++     | 自增运算符，操作数必须是变量，使变量加一                       |
| --     | 自减运算符，操作数必须是变量，使变量减一                       |

#### 补充解释(仅作了解，初学请跳过)：

除法的特殊情况是除数为浮点数0

```
1.0 / 0.0 结果为inf(无穷大)
-1.0 / 0.0 结果为-inf(负无穷)
-1.0 / -0.0 结果为inf(无穷大)
是的，浮点数正零和负零是不同的
```

当负数参与模运算时，运算规则会比较复杂，所以不建议你使用负数参与模运算

一个使用模运算的典型例子是角度限制，将角度转换为在0~359度内的相同角度

```C
int theta = 114514;
theta = theta % 360;
// 这时theta为34

theta = -90
theta = theta % 360;
// 这时theta为-90度，不在我们希望的范围里

// 如果知道theta的输入值的范围，代码可以写成
theta = (theta + 360 * 100) % 360;
// 这时theta为270
// 如果theta < -360 * 100，就会产生非期望的结果
```

自增操作符和自减运算符可以参与复合运算，例如：

```C

int a = 0;
a++; // 等同于a = a + 1
// 这时a为1

++a; // 等同于a++ 不建议使用
// 这时a为2

a = a++; // a++先保留a的值2，再将a自增，最后将2作为结果。因此最后a依然是2

a = ++a; // ++a先将a自增为3，再将3作为++a的结果。因此最后a为3

a = 3 * ++a + a++ - --a; // 不要写这样的代码，不要浪费时间理解这行代码
```

在以上代码中你是否感到自增自减运算符参与运算时会让本来简单的运算变得异常复杂

因此结论是仅像`a++;`或`a--;`这样使用自增自减运算符，不要让它们参与运算

**尝试理解自增自减运算符参与复合计算的代码会变得不幸!!!**

### 关系运算符

| 运算符 | 描述             |
| ------ | ---------------- |
| ==     | 判断相等         |
| <      | 判断是否小于     |
| <=     | 判断是否小于等于 |
| >      | 判断是否大于     |
| >=     | 判断是否大于等于 |
| !=     | 判断是否不等于   |

这里列举几个判断相等的使用场景

```C
float x = 3;
int a = 5;
printf("%d\n", (int)x == x);    // 判断浮点数x是否为整数
printf("%d\n", a % 2 == 0);     // 判断整数a是否为偶数
printf("%d\n", a % 2 != 0);     // 判断整数a是否为奇数
printf("%d\n", a % 7 == 0);     // 判断整数a是否为7的倍数
printf("%d\n", 3.5 <= x && x < 7); // 判断x是否在[3.5, 7)区间内
printf("%d\n", 3.5 <= x < 7); // 典型错误，并且可以编译通过
// 先计算3.5 <= x，返回0或1，0或1一定小于7，所以无论x取什么值，结果都是true
```

使用关系运算符的一个常见错误是混淆`a=b`与`a==b`

关系运算符的结果一定是bool类型

如果a与b相等，`a==b`为true，否则为false

而`a=b`的结果为b

另一个常见错误是判断浮点数是否相等

例如`0.1 + 0.2 == 0.3`的结果竟然是false

因为浮点数是有表示精度的，因此在工程代码中判断浮点数是否相等会使用以下方法：

```C
#include <stdio.h>
#include <math.h> // 使用了math.h中的fabs函数
// fabs是取浮点数绝对值的函数
#define EPSILON 0.000001
// 宏定义语法，将EPSILON定义为常量0.000001

int main()
{
    printf("%d\n", fabs((0.1 + 0.2) - 0.3) <= EPSILON);
    // 判断0.1 + 0.2是否与0.3相等
    return 0;
}
```

只要两个浮点数的距离在容许误差半径(EPSILON)之内就认为两浮点数相等

### 逻辑运算符

| 运算符 | 描述   |
| ------ | ------ |
| &&     | 与运算 |
| \|\|   | 或运算 |
| !      | 非运算 |

为了描述逻辑运算，我们常使用真值表

真值表列举出了所有输入布尔值组合所对应的输出布尔值

与运算有两个布尔型操作数，分别记为A、B，一个布尔输出

可列出与运算真值表如下：

| A   | B   | A && B |
| --- | --- | ------ |
| F   | F   | F      |
| F   | T   | F      |
| T   | F   | F      |
| T   | T   | T      |

例如第一行表示当输入A，B均为F时，输出C为F

或运算真值表如下：

| A   | B   | A \|\| B |
| --- | --- | -------- |
| F   | F   | F        |
| F   | T   | T        |
| T   | F   | T        |
| T   | T   | T        |

非运算只有一个输入，记为A

非运算真值表：

| A   | !A  |
| --- | --- |
| F   | T   |
| T   | F   |

注意逻辑运算符的优先级：

非运算 > 与运算 > 或运算

#### 补充解释(初学者请跳过)：

`或运算`和`与运算`为短路运算符，这指的是如果左操作数能确定逻辑表达式的值，就不会计算右操作数

例如如果左操作数为真，则`或运算`表达式必定为真，就不会计算右操作数

如果左操作数为假，则`与运算`表达式必定为假，也不会计算右操作数

例如：

```C
#include <stdio.h>
#include <stdbool.h>

int main()
{
    printf("%d\n", true || (0 / 0));
    // 输出1，因为左操作数为true，所以不计算0 / 0，直接得到true
    printf("%d\n", true && (0 / 0));
    // 报错，因为左操作数为true，不能确定 与运算 的结果，计算右操作数，得到算数异常
    return 0;
}
```

### 位运算符

位运算作用于每一个二进制位并对每一位进行运算

| 运算符 | 描述                                                                   |
| ------ | ---------------------------------------------------------------------- |
| &      | 按位与运算                                                             |
| \|     | 按位或运算                                                             |
| ~      | 按位非运算                                                             |
| ^      | 按位异或运算                                                           |
| <<     | 左移运算符，将所有的二进制为向左移动，超过左侧的二进制位丢弃，右侧补零 |
| >>     | 右移运算符，将所有的二进制为向右移动，超过右侧的二进制位丢弃，左侧补零 |

如果不溢出，左移n位相当于乘2的n次方，右移n位相当于除2的n次方

异或运算真值表如下：

| A   | B   | A ^ B |
| --- | --- | ----- |
| F   | F   | F     |
| F   | T   | T     |
| T   | F   | T     |
| T   | T   | F     |

例如A = 60，B = 13，用二进制表示，可以写成：

```
A      = 0011 1100
B      = 0000 1101
------------------
A & B  = 0000 1100
A | B  = 0011 1101
A ^ B  = 0011 0001
~A     = 1100 0011
!A     = 0000 0000
A && B = 0000 0001
A || B = 0000 0001
A << 2 = 1111 0000
B >> 2 = 0000 0011
```

位运算常用来操作寄存器标志位

例如一个无符号整数占8比特内存，对应8盏小灯。从右向左数，第1到8位分别对应第1到8盏小灯

```C
#include <stdio.h>

int main()
{
    char n;
    scanf("%d", &n);
    char led_reg = 0b01001001;

    // 亮起第3盏灯
    led_reg = led_reg | 0b00000100;

    // 关闭第7盏灯
    led_reg = led_reg & 0b10111111;

    // 开启第n盏灯
    led_reg =  led_reg | 1 << (n-1);

    // 循环左移一位(第1位移到第2位，第2位移到第3位...第8位移到第1位)
    // 效果是向左的流水灯
    led_reg = ((0b10000000 & led_reg) >> 7) | (led_reg << 1);

    // 循环右移一位(第2位移到第1位，第3位移到第2位...第1位移到第8位)
    // 效果是向右的流水灯
    led_reg = ((0b00000001 & led_reg) << 7) | (led_reg >> 1);

    return 0;
}
```

### 赋值运算符

| 运算符 | 描述                         |
| ------ | ---------------------------- |
| =      | 将右操作数赋值到左侧的变量里 |
| +=     | a += b 等同于 a = a + b      |
| -=     | a -= b 等同于 a = a - b      |
| *=     | a *= b 等同于 a = a * b      |
| /=     | a /= b 等同于 a = a / b      |
| %=     | a %= b 等同于 a = a % b      |
| <<=    | a <<= b 等同于 a = a << b    |
| >>=    | a >>= b 等同于 a = a >> b    |
| &=     | a &= b 等同于 a = a & b      |
| \|=    | a \|= b 等同于 a = a \| b    |
| ^=     | a ^= b 等同于 a = a ^ b      |

### 其他运算符

| 运算符   | 描述                     |
| -------- | ------------------------ |
| sizeof() | 返回变量所占内存的字节数 |

sizeof不是函数，而是运算符，运算结果是unsigned long类型

```C
#include <stdio.h>

int main()
{
    int a = 4;
    short b;
    double c;

    printf("变量 a 占%lu字节\n", sizeof(a));
    printf("变量 b 占%lu字节\n", sizeof(b));
    printf("变量 c 占%lu字节\n", sizeof(c));
    printf("float 占%lu字节\n", sizeof(float));
    printf("double 占%lu字节\n", sizeof(double));

    return 0;
}
```

输出：
```
变量 a 占4字节
变量 b 占2字节
变量 c 占8字节
float 占4字节
double 占8字节
```

## 流程控制语句

程序执行的流程可以分为三类：顺序结构、分支结构、循环结构

### 顺序结构

我们之前所写的程序都是顺序结构的，即按照从前到后的顺序执行

### 分支结构

在C语言中，`if...else`语句和`switch...case`语句均可以实现分支结构程序

#### 使用if实现分支结构

if语句的语法如下

```C
if (条件A) {
    语句块A
}
```

只有当小括号里的条件为真时，才会执行大括号里的语句块A

如果大括号里只有一条语句，可以省略大括号，但不建议你这样做

```C
if (条件) {
    语句块A
}
else {
    语句块B
}
```

当条件为真时，会执行语句块A，否则会执行语句块B

我们可以使用`if...else`语句计算除法，当除数为零时输出错误提示

```C
#include <stdio.h>

int main()
{
    double a, b;
    printf("输入两个数，计算它们的商（用空格隔开）:\n");
    scanf("%lf %lf", &a, &b);
    if (b == 0.0)
    {
        printf("除数不能为0\n");
    }
    else
    {
        printf("%f / %f = %f\n", a, b, a / b);
    }
    return 0;
}
```

以上代码确实实现了上述功能，但是不能很好地区分正常执行和异常执行情况，请想象如果有多个异常情况需要判断，那么需要多个嵌套的if语句

一个常用的技巧叫作提前返回

```C
#include <stdio.h>

int main()
{
    double a, b;
    printf("输入两个数，计算它们的商（用空格隔开）:\n");
    scanf("%lf %lf", &a, &b);
    if (b == 0.0)
    {
        printf("除数不能为0\n");
        return 0; // 在main函数里使用return语句会结束程序
    }
    printf("%f / %f = %f\n", a, b, a / b);
    return 0;
}
```

这样可以明显看出if判断的是异常情况，而不缩进的代码处理正常情况，如果有多个异常情况，可以写多个if语句，不会出现嵌套的情况

```C
if (条件A) {
    语句块A
}
else if (条件B) {
    语句块B
}
else if (条件C) {
    语句块C
}
else {
    语句块D
}
```

C语言允许你使用`else if`语法构建多分支语句，它其实是嵌套的`if ... else`结构

当条件A为真时，执行语句块A，否则判断条件B

当条件B为真时，执行语句块B，否则判断条件C

...

当条件ABC都为假时，执行语句块D

特点是语句块ABCD有且仅有一个被执行

例如：

```C
#include <stdio.h>

int main()
{
    long long score;
    printf("你高考考了多少分啊？\n");
    scanf("%lld", &score);

    // 处理分数不在正常区间内的情况
    if (score < 0)
    {
        printf("你考的什么试？\n");
        return 0;
    }
    if (score > 750)
    {
        printf("750分是试卷的极限，不是你的极限\n");
        return 0;
    }

    if (score >= 600)
    {
        printf("上清北\n");
    }
    else if (400 <= score && score < 600)
    {
        printf("上燕大\n");
    }
    else if (200 <= score && score < 400)
    {
        printf("上鸟专\n");
    }
    else
    {
        printf("烤面筋\n");
    }

    return 0;
}
```

#### 使用switch实现分支结构

`switch` 语句的基本结构如下：

```C
switch (表达式) {
    case 常量1:
        // 当 表达式 等于 常量1 时执行的代码
        break;
    case 常量2:
        // 当 表达式 等于 常量2 时执行的代码
        break;
    ...
    default:
        // 当 表达式 不等于任何一个 case 常量时执行的代码
}
```

其中：
- `表达式` 是一个整数类型的表达式，它的值将用于与各个 `case` 标签进行匹配。
- `case 常量` 是 `switch` 语句中的标签，每个 `case` 后跟随一个常量值，当 `表达式` 的值与某个 `case` 的常量值匹配时，执行该 `case` 下的代码。
- `break` 语句用于终止 `switch` 语句。如果没有 `break`，程序将继续执行后面的 `case` 或 `default` 代码，直到遇到 `break` 或 `switch` 语句结束。
- `default` 是可选的，用于在没有任何 `case` 匹配时执行默认代码。

让我们通过一个示例来演示 `switch` 语句的使用。假设我们有一个表示星期几的变量，我们希望根据这个变量的值打印相应的星期几名称。

```c
#include <stdio.h>

int main() {
    int day = 3;

    switch (day) {
        case 1:
            printf("星期一\n");
            break;
        case 2:
            printf("星期二\n");
            break;
        case 3:
            printf("星期三\n");
            break;
        case 4:
            printf("星期四\n");
            break;
        case 5:
            printf("星期五\n");
            break;
        case 6:
            printf("星期六\n");
            break;
        case 7:
            printf("星期日\n");
            break;
        default:
            printf("无效的星期\n");
    }

    return 0;
}
```

在这个示例中，如果 `day` 的值是 3，程序将输出 "星期三"。如果 `day` 的值不是 1 到 7 之间的任何一个数值，程序将输出 "无效的星期"

有时候，使用我们即将讲到的数组来代替`switch`会是一个更好的选择

一个使用`switch`语句的典型错误是在`case`后面放置变量

例如

```C
int n;
scanf("%d", &n);

switch (day) {
    case 1:
        printf("星期一\n");
        break;
    case n: // n是一个变量，它的值不能在编译时确定
        printf("星期二\n");
        break;
    ...
}
```

### 循环结构

#### 使用while实现循环

`while` 循环是C语言中最常用的循环结构之一。它用于重复执行一段代码，直到指定的条件为假。

`while` 循环的基本结构如下：

```C
while (条件) {
    // 循环体
}
```

- `条件` 是一个布尔表达式
- 当 `条件` 为真时，循环体中的代码将被执行
- 当 `条件` 为假时，循环结束，程序将继续执行循环体之后的代码

下面是一个简单的示例，使用 `while` 循环打印从1到10的数字：

```C
#include <stdio.h>

int main() {
    int i = 1;

    while (i <= 10) {
        printf("%d\n", i);
        i++;
    }

    return 0;
}
```

在这个示例中，`i` 初始化为1，然后 `while` 循环检查 `i` 是否小于或等于10。如果条件为真，打印 `i` 的值，然后 `i` 增加1。这个过程重复进行，直到 `i` 大于10，循环结束。

下面是一个使用 `while` 循环计算一个正整数的阶乘的示例：

```c
#include <stdio.h>

int main() {
    int n;
    int result = 1;

    printf("请输入一个正整数：");
    scanf("%d", &n);

    int i = 1;
    while (i <= n) {
        result *= i;
        i++;
    }

    printf("%d 的阶乘是 %d\n", n, result);

    return 0;
}
```

在这个示例中，用户输入一个正整数 `n`，然后 `while` 循环计算 `n` 的阶乘。`i` 初始化为1，然后每次循环中 `result` 乘以 `i`，并且 `i` 增加1。这个过程重复进行，直到 `i` 大于 `n`。

如果 `循环条件` 永远为真，`while` 循环将成为一个无限循环。例如：

```c
#include <stdio.h>

int main() {
    while (1) {
        printf("这是一个无限循环\n");
    }

    return 0;
}
```

在这个示例中，由于 `循环条件` 总是为1（真），循环体将一直执行，直到程序被强制终止。

你可能遇到的典型错误是`写错循环条件`或`忘记改变循环变量`导致程序陷入无限循环

```C
int i, j;
i = j = 0;

while (i <= 10) {
    printf("%d\n", i);
    j++;
}
```

显然这个程序会陷入无限循环

#### 使用for实现循环

`for` 循环是 C 语言中另一种常用的循环结构。它在执行固定次数的循环时特别有用。`for` 循环将初始化、条件测试和更新步骤集中在一行中，使代码更加紧凑和易读。

`for` 循环的基本结构如下：

```C
for (初始化语句; 条件表达式; 更新语句) {
    // 循环体
}
```

其中：
- `初始化语句`：在循环开始时执行一次，用于初始化循环控制变量。
- `条件表达式`：在每次迭代前测试。如果条件为真，执行循环体；如果为假，结束循环。
- `更新语句`：每次执行完循环体后执行，用于更新循环控制变量。

下面是一个简单的示例，使用 `for` 循环打印从1到10的数字：

```C
#include <stdio.h>

int main() {
    for (int i = 1; i <= 10; i++) {
        printf("%d\n", i);
    }

    return 0;
}
```

在这个示例中，`i` 初始化为1，然后 `for` 循环检查 `i` 是否小于或等于10。如果条件为真，打印 `i` 的值，然后 `i` 增加1。这个过程重复进行，直到 `i` 大于10，循环结束。

下面是一个使用 `for` 循环计算一个正整数的阶乘的示例：

```C
#include <stdio.h>

int main() {
    int n;
    int result = 1;

    printf("请输入一个正整数：");
    scanf("%d", &n);

    for (int i = 1; i <= n; i++) {
        result *= i;
    }

    printf("%d 的阶乘是 %d\n", n, result);

    return 0;
}
```

在这个示例中，用户输入一个正整数 `n`，然后 `for` 循环计算 `n` 的阶乘。`i` 初始化为1，然后每次循环中 `result` 乘以 `i`，并且 `i` 增加1。这个过程重复进行，直到 `i` 大于 `n`。

`for` 循环可以嵌套使用，即一个 `for` 循环体内可以包含另一个 `for` 循环。

下面是一个使用嵌套 `for` 循环打印乘法表的示例：

```C
#include <stdio.h>

int main() {
    for (int i = 1; i <= 9; i++) {
        for (int j = 1; j <= 9; j++) {
            printf("%d * %d = %2d  ", i, j, i * j);
        }
        printf("\n");
    }

    return 0;
}
```

在这个示例中，外层循环控制行数，内层循环控制列数，打印1到9的乘法表。

在 `for` 循环中，`初始化语句`、`条件表达式` 和 `更新语句` 都是可选的。你可以根据需要省略其中的一部分，甚至全部省略，但分号不能省略。例如：

```C
int i = 1;
for (;i <= 10;) {
    printf("%d\n", i);
    i++;
}
```

在这个示例中，`初始化语句` 被移到 `for` 循环外部，而 `更新语句` 被放到循环体内部。

#### 使用continue和break语句控制循环

`continue` 用于跳过当前迭循环剩余部分并开始下一次循环，而 `break` 用于立即终止循环。

我们将结合使用 `continue` 和 `break`，跳过数字 5，并在遇到数字 8 时提前终止循环。

```C
#include <stdio.h>

int main() {
    for (int i = 1; i <= 10; i++) {
        if (i == 5) {
            continue;  // 跳过数字 5
        }
        if (i == 8) {
            break;  // 遇到数字 8 时提前终止循环
        }
        printf("%d\n", i);
    }

    return 0;
}
```

在这个示例中，当 `i` 等于 5 时，`continue` 语句会跳过 `printf("%d\n", i);`，直接开始下一次循环。当 `i` 等于 8 时，`break` 语句会终止 `for` 循环，程序继续执行 `for` 循环后的代码。因此，输出结果将是 1 到 4 和 6 到 7。

在嵌套的循环中，内层循环的`continue`和`break`只作用于内层循环，如果在内层想跳出外层循环，需要使用标志变量

例如

```C
bool flag = false;
for (int i = 0; i < 10; i++) {
    for (int i = 0; j < 10; j++) {
        printf("%d %d\n");
        if (i * j == 45) {
            flag = true;    // 设置循环变量
            break;          // 通过循环变量跳到外层循环外
        }
    }
    if (flag) {
        break;
    }
}
```

### 枚举算法

#### 使用枚举算法判断水仙花数

水仙花数是指一个 n 位正整数，其各个位上的数字的 n 次方之和等于它本身。例如，三位数 153 是一个水仙花数，因为 
$$ 153 = 1^3 + 5^3 + 3^3 $$

枚举算法是一种简单而直接的方法，通过系统地列举所有可能的情况来找到问题的解。对于判断一个数是否为水仙花数，我们可以通过枚举所有的三位数来判断其中哪些是水仙花数。

1. **初始化**：确定枚举的范围，对于三位数来说，范围是 100 到 999。
2. **遍历**：遍历每一个数，分解出它的各个位上的数字。
3. **计算**：计算各个位上的数字的立方和。
4. **判断**：比较计算结果和原数，如果相等，则该数是水仙花数。

下面是使用枚举算法判断三位数水仙花数的代码：

```C
#include <stdio.h>
#include <math.h>   // 使用数学库math.h中的幂运算函数pow

int main() {
    int number, digit, sum;
    printf("三位数的水仙花数有：\n");

    for (number = 100; number <= 999; number++) {
        int temp = number;
        sum = 0;

        while (temp != 0) {
            digit = temp % 10;        // 获取最后一位数字
            sum += pow(digit, 3);     // 计算数字的立方和
            // pow(x, 3) 等同于 x * x * x
            temp /= 10;               // 去掉最后一位数字
        }

        if (sum == number) {
            printf("%d\n", number);   // 输出水仙花数
        }
    }

    return 0;
}
```

### 末尾的话

还有一种循环语句是`do...while`语句，但它可以被`while`语句等效替换，不常用所以不讲

`goto`是无条件跳转语句，不要学习`goto`，不要使用`goto`！

如果你了解三元运算符，你可能疑惑为什么没有讲到它，请看：

[为什么 Python, Go, Rust, Kotlin 没有三元运算符](https://www.bilibili.com/video/BV1v64y1J7hS/)

    Go语言中没有三元运算符的原因是，语言设计者们发现这个操作经常被过度使用，导致生成难以理解的复杂表达式。

    虽然 if-else 形式更长，但毫无疑问更加清晰。一门语言只需要一种条件控制结构